/*
 * generated by Xtext 2.27.0
 */
package mde.pauline.metaheres.serializer;

import com.google.inject.Inject;
import java.util.Set;
import mde.pauline.metaheres.services.MyGrammarAccess;
import metaheres.Country;
import metaheres.Language;
import metaheres.LotsConfig;
import metaheres.MetaheresPackage;
import metaheres.PricingSystem;
import metaheres.ReservationsConfig;
import metaheres.ResourcesConfig;
import metaheres.ServiceConfig;
import metaheres.ServiceName;
import metaheres.Status;
import metaheres.StatusList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class MySemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MetaheresPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MetaheresPackage.COUNTRY:
				sequence_Country(context, (Country) semanticObject); 
				return; 
			case MetaheresPackage.LANGUAGE:
				sequence_Language(context, (Language) semanticObject); 
				return; 
			case MetaheresPackage.LOTS_CONFIG:
				sequence_LotsConfig(context, (LotsConfig) semanticObject); 
				return; 
			case MetaheresPackage.PRICING_SYSTEM:
				sequence_PricingSystem(context, (PricingSystem) semanticObject); 
				return; 
			case MetaheresPackage.RESERVATIONS_CONFIG:
				sequence_ReservationsConfig(context, (ReservationsConfig) semanticObject); 
				return; 
			case MetaheresPackage.RESOURCES_CONFIG:
				sequence_ResourcesConfig(context, (ResourcesConfig) semanticObject); 
				return; 
			case MetaheresPackage.SERVICE_CONFIG:
				sequence_ServiceConfig(context, (ServiceConfig) semanticObject); 
				return; 
			case MetaheresPackage.SERVICE_NAME:
				sequence_SServiceName(context, (ServiceName) semanticObject); 
				return; 
			case MetaheresPackage.STATUS:
				sequence_Status(context, (Status) semanticObject); 
				return; 
			case MetaheresPackage.STATUS_LIST:
				sequence_StatusList(context, (StatusList) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Country returns Country
	 *
	 * Constraint:
	 *     (name=EString language=Language pricingsystem=PricingSystem)
	 * </pre>
	 */
	protected void sequence_Country(ISerializationContext context, Country semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetaheresPackage.Literals.COUNTRY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaheresPackage.Literals.COUNTRY__NAME));
			if (transientValues.isValueTransient(semanticObject, MetaheresPackage.Literals.COUNTRY__LANGUAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaheresPackage.Literals.COUNTRY__LANGUAGE));
			if (transientValues.isValueTransient(semanticObject, MetaheresPackage.Literals.COUNTRY__PRICINGSYSTEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaheresPackage.Literals.COUNTRY__PRICINGSYSTEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCountryAccess().getNameEStringParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCountryAccess().getLanguageLanguageParserRuleCall_2_0(), semanticObject.getLanguage());
		feeder.accept(grammarAccess.getCountryAccess().getPricingsystemPricingSystemParserRuleCall_6_0(), semanticObject.getPricingsystem());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Language returns Language
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_Language(ISerializationContext context, Language semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetaheresPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaheresPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLanguageAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LotsConfig returns LotsConfig
	 *
	 * Constraint:
	 *     (hasImage?='hasImage'? hasOneStockPerSlot?='hasOneStockPerSlot'?)
	 * </pre>
	 */
	protected void sequence_LotsConfig(ISerializationContext context, LotsConfig semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PricingSystem returns PricingSystem
	 *
	 * Constraint:
	 *     (name=EString currency=EString taxSystem=EString)
	 * </pre>
	 */
	protected void sequence_PricingSystem(ISerializationContext context, PricingSystem semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetaheresPackage.Literals.PRICING_SYSTEM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaheresPackage.Literals.PRICING_SYSTEM__NAME));
			if (transientValues.isValueTransient(semanticObject, MetaheresPackage.Literals.PRICING_SYSTEM__CURRENCY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaheresPackage.Literals.PRICING_SYSTEM__CURRENCY));
			if (transientValues.isValueTransient(semanticObject, MetaheresPackage.Literals.PRICING_SYSTEM__TAX_SYSTEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaheresPackage.Literals.PRICING_SYSTEM__TAX_SYSTEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPricingSystemAccess().getNameEStringParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPricingSystemAccess().getCurrencyEStringParserRuleCall_3_0(), semanticObject.getCurrency());
		feeder.accept(grammarAccess.getPricingSystemAccess().getTaxSystemEStringParserRuleCall_6_0(), semanticObject.getTaxSystem());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReservationsConfig returns ReservationsConfig
	 *
	 * Constraint:
	 *     (hasMoveOutCheck?='hasMoveOutCheck' hasMoveInCheck?='hasMoveInCheck'? minRequestAdvance=EInt maxRequestAdvance=EInt statuslist=StatusList)
	 * </pre>
	 */
	protected void sequence_ReservationsConfig(ISerializationContext context, ReservationsConfig semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ResourcesConfig returns ResourcesConfig
	 *
	 * Constraint:
	 *     (hasImage?='hasImage'? hasOneStockPerSlot?='hasOneStockPerSlot'? isConsumable?='isConsumable' isLoan?='isLoan'? isCharged?='isCharged'?)
	 * </pre>
	 */
	protected void sequence_ResourcesConfig(ISerializationContext context, ResourcesConfig semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SServiceName returns ServiceName
	 *
	 * Constraint:
	 *     (name=EString serviceconfig=ServiceConfig)
	 * </pre>
	 */
	protected void sequence_SServiceName(ISerializationContext context, ServiceName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetaheresPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaheresPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, MetaheresPackage.Literals.SERVICE_NAME__SERVICECONFIG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaheresPackage.Literals.SERVICE_NAME__SERVICECONFIG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSServiceNameAccess().getNameEStringParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSServiceNameAccess().getServiceconfigServiceConfigParserRuleCall_2_0(), semanticObject.getServiceconfig());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ServiceConfig returns ServiceConfig
	 *
	 * Constraint:
	 *     (
	 *         closesOnPublicHolidays?='closesOnPublicHolidays'? 
	 *         inventoryIsPublic?='inventoryIsPublic'? 
	 *         hasChart?='hasChart'? 
	 *         countInBusinessDays?='countInBusinessDays'? 
	 *         country+=Country 
	 *         country+=Country* 
	 *         (pricingsystem+=[PricingSystem|EString] pricingsystem+=[PricingSystem|EString]*)? 
	 *         language+=Language 
	 *         language+=Language* 
	 *         reservationsconfig=ReservationsConfig 
	 *         resourcesconfig+=ResourcesConfig 
	 *         resourcesconfig+=ResourcesConfig* 
	 *         lotsconfig=LotsConfig?
	 *     )
	 * </pre>
	 */
	protected void sequence_ServiceConfig(ISerializationContext context, ServiceConfig semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StatusList returns StatusList
	 *
	 * Constraint:
	 *     (status+=Status status+=Status*)
	 * </pre>
	 */
	protected void sequence_StatusList(ISerializationContext context, StatusList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Status returns Status
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_Status(ISerializationContext context, Status semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetaheresPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaheresPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStatusAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
